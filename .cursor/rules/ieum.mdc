---
alwaysApply: true
---

# Swift iOS Project Cursor Rules

## Tech Stack
- UIKit (Code-based, No Storyboard)
- Architecture: MVVM + Combine + Coordinator
- UI: SnapKit, Then
- Networking: Alamofire with Interceptors
- SwiftUI integration via UIHostingController when needed

## Project Structure
```
├── App/
├── Presentation/
│   ├── Coordinator/
│   │   ├── AppCoordinator.swift
│   │   ├── AuthCoordinator.swift
│   │   └── [Feature]Coordinator.swift
│   ├── [Feature]/
│   │   ├── View/
│   │   │   ├── [Feature]ViewController.swift
│   │   │   └── [Feature]View.swift (SwiftUI, optional)
│   │   └── ViewModel/
│   │       └── [Feature]ViewModel.swift
│   ├── Common/
│   │   ├── Base/
│   │   └── Components/
│   └── Theme/
│       ├── Colors.swift
│       ├── Fonts.swift
│       └── Theme.swift
├── Domain/
│   ├── Entities/
│   └── UseCases/
├── Data/
│   ├── Network/
│   │   ├── API/
│   │   ├── Interceptors/
│   │   └── Endpoints/
│   └── DTOs/
└── Core/
    ├── Extensions/
    └── Utils/
```

## Theme System

### Colors
```swift
enum Colors {
    static let primary = UIColor.systemBlue
    static let secondary = UIColor.systemGray
    static let background = UIColor.systemBackground
    static let text = UIColor.label
    static let error = UIColor.systemRed
}
```

### Fonts
```swift
enum Fonts {
    static let largeTitle = UIFont.systemFont(ofSize: 34, weight: .bold)
    static let title = UIFont.systemFont(ofSize: 24, weight: .semibold)
    static let body = UIFont.systemFont(ofSize: 16, weight: .regular)
    static let caption = UIFont.systemFont(ofSize: 12, weight: .regular)
}
```

## Coordinator Pattern

### Coordinator Protocol
```swift
protocol Coordinator: AnyObject {
    var childCoordinators: [Coordinator] { get set }
    var navigationController: UINavigationController { get set }
    
    func start()
    func finish()
}

extension Coordinator {
    func addChild(_ coordinator: Coordinator) {
        childCoordinators.append(coordinator)
    }
    
    func removeChild(_ coordinator: Coordinator) {
        childCoordinators.removeAll { $0 === coordinator }
    }
    
    func finish() {
        childCoordinators.removeAll()
    }
}
```

### AppCoordinator Template
```swift
final class AppCoordinator: Coordinator {
    var childCoordinators: [Coordinator] = []
    var navigationController: UINavigationController
    
    private let window: UIWindow
    
    init(window: UIWindow) {
        self.window = window
        self.navigationController = UINavigationController()
    }
    
    func start() {
        window.rootViewController = navigationController
        window.makeKeyAndVisible()
        
        showSplash()
    }
    
    private func showSplash() {
        let coordinator = SplashCoordinator(navigationController: navigationController)
        coordinator.delegate = self
        addChild(coordinator)
        coordinator.start()
    }
}

extension AppCoordinator: SplashCoordinatorDelegate {
    func didFinishSplash() {
        removeChild(childCoordinators.first!)
        showAuth()
    }
    
    private func showAuth() {
        let coordinator = AuthCoordinator(navigationController: navigationController)
        addChild(coordinator)
        coordinator.start()
    }
}
```

### Feature Coordinator Template
```swift
protocol AuthCoordinatorDelegate: AnyObject {
    func didFinishAuth()
}

final class AuthCoordinator: Coordinator {
    var childCoordinators: [Coordinator] = []
    var navigationController: UINavigationController
    
    weak var delegate: AuthCoordinatorDelegate?
    
    init(navigationController: UINavigationController) {
        self.navigationController = navigationController
    }
    
    func start() {
        showLogin()
    }
    
    private func showLogin() {
        let viewModel = LoginViewModel()
        let viewController = LoginViewController(viewModel: viewModel, coordinator: self)
        navigationController.setViewControllers([viewController], animated: false)
    }
    
    func showSignUp() {
        let coordinator = SignUpCoordinator(navigationController: navigationController)
        coordinator.delegate = self
        addChild(coordinator)
        coordinator.start()
    }
    
    func showMain() {
        delegate?.didFinishAuth()
    }
}

extension AuthCoordinator: SignUpCoordinatorDelegate {
    func didFinishSignUp() {
        removeChild(childCoordinators.first!)
        showMain()
    }
}
```

## ViewController Template
```swift
final class ExampleViewController: UIViewController {
    private let viewModel: ExampleViewModel
    private let coordinator: ExampleCoordinator?
    private var cancellables = Set<AnyCancellable>()
    
    private let titleLabel = UILabel().then {
        $0.textColor = Colors.text
        $0.font = Fonts.title
    }
    
    init(viewModel: ExampleViewModel, coordinator: ExampleCoordinator? = nil) {
        self.viewModel = viewModel
        self.coordinator = coordinator
        super.init(nibName: nil, bundle: nil)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        bindViewModel()
    }
    
    private func setupUI() {
        view.backgroundColor = Colors.background
        view.addSubview(titleLabel)
        
        titleLabel.snp.makeConstraints { make in
            make.center.equalToSuperview()
        }
    }
    
    private func bindViewModel() {
        viewModel.$title
            .receive(on: DispatchQueue.main)
            .sink { [weak self] title in
                self?.titleLabel.text = title
            }
            .store(in: &cancellables)
        
        // Navigation events from ViewModel
        viewModel.navigateToNext
            .sink { [weak self] in
                self?.coordinator?.showNext()
            }
            .store(in: &cancellables)
    }
}
```

## ViewModel Template
```swift
final class ExampleViewModel: ObservableObject {
    // Inputs
    let viewDidLoad = PassthroughSubject<Void, Never>()
    let didTapNextButton = PassthroughSubject<Void, Never>()
    
    // Outputs
    @Published private(set) var title = ""
    @Published private(set) var isLoading = false
    
    // Navigation Events (bound to Coordinator)
    let navigateToNext = PassthroughSubject<Void, Never>()
    
    private let useCase: ExampleUseCase
    private var cancellables = Set<AnyCancellable>()
    
    init(useCase: ExampleUseCase) {
        self.useCase = useCase
        bindInputs()
    }
    
    private func bindInputs() {
        viewDidLoad
            .sink { [weak self] in self?.loadData() }
            .store(in: &cancellables)
        
        didTapNextButton
            .sink { [weak self] in
                self?.navigateToNext.send()
            }
            .store(in: &cancellables)
    }
    
    private func loadData() {
        isLoading = true
        // API call...
    }
}
```

## SwiftUI Integration
```swift
struct ExampleView: View {
    @ObservedObject var viewModel: ExampleViewModel
    
    var body: some View {
        Text(viewModel.title)
            .onAppear { viewModel.viewDidLoad.send() }
    }
}

// In ViewController
let hostingController = UIHostingController(rootView: ExampleView(viewModel: viewModel))
```

## Networking
```swift
// API Service
final class APIService {
    private let session: Session
    
    init() {
        session = Session(interceptor: AuthInterceptor())
    }
    
    func request<T: Decodable>(_ endpoint: Endpoint) -> AnyPublisher<T, Error> {
        session.request(endpoint.url, method: endpoint.method)
            .validate()
            .publishDecodable(type: T.self)
            .value()
            .eraseToAnyPublisher()
    }
}

// Interceptor
final class AuthInterceptor: RequestInterceptor {
    func adapt(_ urlRequest: URLRequest, for session: Session, completion: @escaping (Result<URLRequest, Error>) -> Void) {
        var request = urlRequest
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        completion(.success(request))
    }
}
```

## Code Conventions
- Use `weak self` in closures
- No force unwrapping
- Use Theme colors/fonts consistently
- Store Combine subscriptions in `cancellables`
- Use `receive(on: DispatchQueue.main)` for UI updates
- ViewControllers suffix: `ViewController`
- ViewModels suffix: `ViewModel`
- Coordinators suffix: `Coordinator`
- Keep ViewControllers lightweight (logic in ViewModel)
- Use dependency injection
- **Navigation**: ViewControllers should NOT directly create or push other ViewControllers. Use Coordinators for all navigation.
- **Coordinator Pattern**: Each feature flow should have its own Coordinator. ViewControllers communicate navigation needs through ViewModel → Coordinator.
- **Combine + Coordinator**: ViewModel publishes navigation events (PassthroughSubject), ViewController binds to Coordinator methods.